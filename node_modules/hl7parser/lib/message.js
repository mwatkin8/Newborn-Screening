var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var nodeBase_1 = require('./nodeBase');
var delimiters_1 = require("./delimiters");
var segmentList_1 = require("./segmentList");
var segment_1 = require("./segment");
var Util = require("./util");
var Message = (function (_super) {
    __extends(Message, _super);
    function Message(text) {
        if (text === void 0) { text = "MSH|^~\\&"; }
        _super.call(this, null, text, delimiters_1.default.Segment);
        // make sure message starts with MSH segment
        if (text.slice(0, 3) != "MSH") {
            throw new Error("Message must being with the MSH segment.");
        }
        // read delimiters
        this._delimiters = "\r" + text.slice(3, 8);
        // if delimiters are the standard set, use the cached RegExp. if not, create RegExp for escape/unescape
        if (this._delimiters === Message._defaultDelimiters) {
            this._matchUnescape = Message._defaultMatchUnescape;
            this._matchEscape = Message._defaultMatchEscape;
        }
        else {
            this._matchUnescape = Message._makeMatchUnescape(this._delimiters);
            this._matchEscape = Message._makeMatchEscape(this._delimiters);
        }
    }
    Message._makeMatchUnescape = function (delimiters) {
        // setup regular expression for matching escape sequences, see http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/
        var matchEscape = Util.escapeForRegExp(delimiters[delimiters_1.default.Escape]);
        return new RegExp([matchEscape, "[^", matchEscape, "]*", matchEscape].join(""), "g");
    };
    Message._makeMatchEscape = function (delimiters) {
        var sequences = [
            Util.escapeForRegExp(delimiters[delimiters_1.default.Escape]),
            Util.escapeForRegExp(delimiters[delimiters_1.default.Field]),
            Util.escapeForRegExp(delimiters[delimiters_1.default.Repetition]),
            Util.escapeForRegExp(delimiters[delimiters_1.default.Component]),
            Util.escapeForRegExp(delimiters[delimiters_1.default.SubComponent]),
        ];
        return new RegExp(sequences.join("|"), "g");
    };
    Object.defineProperty(Message.prototype, "delimiters", {
        get: function () {
            return this._delimiters;
        },
        enumerable: true,
        configurable: true
    });
    Message.prototype.unescape = function (text) {
        var _this = this;
        if (text == null)
            return null;
        // Slightly faster for normal case of no escape sequences in text
        if (text.indexOf(this._delimiters[delimiters_1.default.Escape]) == -1)
            return text;
        return text.replace(this._matchUnescape, function (match) {
            switch (match.slice(1, 2)) {
                case "C":
                    // ignore single-byte escape sequence
                    break;
                case "E":
                    return _this._delimiters[delimiters_1.default.Escape];
                case "F":
                    return _this._delimiters[delimiters_1.default.Field];
                case "H":
                    // ignore start highlight
                    break;
                case "M":
                    // ignore multi-byte escape sequence
                    break;
                case "N":
                    // ignore stop highlight
                    break;
                case "R":
                    return _this._delimiters[delimiters_1.default.Repetition];
                case "S":
                    return _this._delimiters[delimiters_1.default.Component];
                case "T":
                    return _this._delimiters[delimiters_1.default.SubComponent];
                case "X":
                    return Util.decodeHexString(match.slice(2, match.length - 1));
                case "Z":
                    // ignore locally defined escape sequence
                    break;
                default:
                    // pass through unknown escape sequences
                    return match;
            }
            return "";
        });
    };
    Message.prototype.escape = function (text) {
        var _this = this;
        if (text == null)
            return null;
        return text.replace(this._matchEscape, function (match) {
            var ch;
            switch (match) {
                case _this._delimiters[delimiters_1.default.Escape]:
                    ch = "E";
                    break;
                case _this._delimiters[delimiters_1.default.Field]:
                    ch = "F";
                    break;
                case _this._delimiters[delimiters_1.default.Repetition]:
                    ch = "R";
                    break;
                case _this._delimiters[delimiters_1.default.Component]:
                    ch = "S";
                    break;
                case _this._delimiters[delimiters_1.default.SubComponent]:
                    ch = "T";
                    break;
            }
            if (ch) {
                var escape = _this._delimiters[delimiters_1.default.Escape];
                return escape + ch + escape;
            }
            throw new Error("Escape sequence for '" + match + "' is not known.");
        });
    };
    Message.prototype.addSegment = function (path) {
        if (!path) {
            throw new Error("Missing segment path.");
        }
        var preparedPath = this.preparePath(path);
        if (preparedPath.length != 1) {
            throw new Error("Invalid segment path '" + path + "'.");
        }
        return this.addChild(preparedPath[0]);
    };
    Message.prototype.read = function (path) {
        var segmentName = path.shift();
        if (path.length == 0) {
            // only the segment name was in the path so return a SegmentList
            var segments = this.children.filter(function (x) { return x.name == segmentName; });
            if (segments.length > 0) {
                return new segmentList_1.default(this, segments);
            }
        }
        else {
            var segment = this._getFirstSegment(segmentName);
            if (segment) {
                return segment.read(path);
            }
        }
        return null;
    };
    Message.prototype.writeCore = function (path, value) {
        var segmentName = path.shift();
        var index = this._getFirstSegmentIndex(segmentName);
        if (index === undefined) {
            index = this.children.length;
        }
        return this.writeAtIndex(path, value, index, segmentName);
    };
    Message.prototype.createChild = function (text, index) {
        // make sure to remove any \n that might follow the \r
        return new segment_1.default(this, text.trim());
    };
    Message.prototype.pathCore = function () {
        // the message has an empty path
        return [];
    };
    Message.prototype._getFirstSegment = function (name) {
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            var segment = children[i];
            if (segment.name == name) {
                return segment;
            }
        }
    };
    Message.prototype._getFirstSegmentIndex = function (name) {
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            var segment = children[i];
            if (segment.name == name) {
                return i;
            }
        }
    };
    Message._defaultDelimiters = "\r|^~\\&";
    Message._defaultMatchUnescape = Message._makeMatchUnescape(Message._defaultDelimiters);
    Message._defaultMatchEscape = Message._makeMatchEscape(Message._defaultDelimiters);
    return Message;
})(nodeBase_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Message;
