var emptyNode_1 = require("./emptyNode");
var Util = require("./util");
var NodeBase = (function () {
    function NodeBase(parent, text, delimiter) {
        if (text === void 0) { text = null; }
        if (delimiter === void 0) { delimiter = undefined; }
        this.parent = parent;
        this._text = text;
        this._delimiter = delimiter;
        this._dirty = false;
    }
    NodeBase.prototype.get = function (path) {
        var ret;
        if (typeof path === "number") {
            if (path >= 0 && path < this.children.length) {
                ret = this.children[path];
            }
        }
        else if (typeof path === "string") {
            ret = this.read(this.preparePath(path));
        }
        return ret || NodeBase.empty;
    };
    NodeBase.prototype.set = function (path, value) {
        // If there is only one argument we make sure the path exists and return it
        if (arguments.length == 1) {
            return this.ensure(path);
        }
        if (typeof path === "string") {
            if (Array.isArray(value)) {
                // If the value is an array, write each item in the array using the index of the item as an additional
                // step in the path.
                for (var i = 0, l = value.length; i < l; i++) {
                    this.set(path + "." + (i + 1), value[i]);
                }
            }
            else {
                this.write(this.preparePath(path), this.prepareValue(value));
            }
            return this;
        }
        else if (typeof path === "number") {
            if (Array.isArray(value)) {
                // If the value is an array, write each item in the array using the index of the item as an additional
                // step in the path.
                var child = this.ensure(path);
                for (var i = 0, l = value.length; i < l; i++) {
                    child.set(i, value[i]);
                }
                return this;
            }
            else {
                this.setChild(this.createChild(this.prepareValue(value), path), path);
            }
            return this;
        }
        throw new Error("Path must be a string or number.");
    };
    Object.defineProperty(NodeBase.prototype, "name", {
        get: function () {
            if (this._name !== undefined)
                return this._name;
            return this._name = this.path.join(".");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "length", {
        get: function () {
            return this.children.length;
        },
        enumerable: true,
        configurable: true
    });
    NodeBase.prototype.toString = function () {
        return this.toRaw();
    };
    NodeBase.prototype.toRaw = function () {
        if (!this._dirty) {
            return this._text;
        }
        this._dirty = false;
        return this._text = this.children.map(function (x) { return x.toRaw(); }).join(this.delimiter);
    };
    NodeBase.prototype.toArray = function () {
        // return shallow clone of children
        return [].concat(this.children);
    };
    NodeBase.prototype.forEach = function (callback) {
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            callback(children[i], i);
        }
    };
    NodeBase.prototype.exists = function (path) {
        var value = this.get(path);
        if (value == null)
            return false;
        return !value.isEmpty();
    };
    NodeBase.prototype.isEmpty = function () {
        return this.children.length == 0;
    };
    NodeBase.prototype.toDate = function () {
        return null;
    };
    NodeBase.prototype.toInteger = function () {
        return null;
    };
    NodeBase.prototype.toFloat = function () {
        return null;
    };
    NodeBase.prototype.toBoolean = function () {
        return null;
    };
    NodeBase.prototype.ensure = function (path) {
        var ret = this.get(path);
        if (ret != NodeBase.empty) {
            return ret;
        }
        if (typeof path === "number") {
            return this.setChild(this.createChild("", path), path);
        }
        else if (typeof path === "string") {
            return this.write(this.preparePath(path), "");
        }
    };
    NodeBase.prototype.preparePath = function (path) {
        var parts = path.split(".");
        if (parts[0] == "") {
            parts.shift();
            parts = this.path.concat(parts);
        }
        if (!this._isSubPath(parts)) {
            throw new Error("'" + parts.toString() + "' is not a sub-path of '" + this.path.toString() + "'");
        }
        return this._remainderOf(parts);
    };
    NodeBase.prototype.prepareValue = function (value) {
        if (value == null)
            return "";
        if (typeof value === "string") {
            return this.message.escape(value);
        }
        if (typeof value === "number") {
            return value.toString();
        }
        if (typeof value === "boolean") {
            return value ? "Y" : "N";
        }
        if (value instanceof Date) {
            return this._formatDateTime(value);
        }
        return value.toString();
    };
    Object.defineProperty(NodeBase.prototype, "message", {
        get: function () {
            if (this._message)
                return this._message;
            return this._message = this.parent ? this.parent.message : this;
        },
        enumerable: true,
        configurable: true
    });
    NodeBase.prototype.read = function (path) {
        throw new Error("Not implemented");
    };
    NodeBase.prototype.write = function (path, value) {
        this.setDirty();
        return this.writeCore(path, value == null ? "" : value);
    };
    NodeBase.prototype.writeCore = function (path, value) {
        throw new Error("Not implemented.");
    };
    NodeBase.prototype.writeAtIndex = function (path, value, index, emptyValue) {
        if (emptyValue === void 0) { emptyValue = ""; }
        var child;
        if (path.length == 0) {
            child = this.createChild(value || emptyValue, index);
        }
        else {
            // check if we already have a child at that index
            if (index < this.children.length) {
                child = this.children[index];
            }
            else {
                // if not, create a new one
                child = this.createChild(emptyValue, index);
            }
        }
        this.setChild(child, index);
        if (path.length != 0) {
            return child.write(path, value);
        }
        return child;
    };
    Object.defineProperty(NodeBase.prototype, "path", {
        get: function () {
            if (this._path)
                return this._path;
            return this._path = this.pathCore();
        },
        enumerable: true,
        configurable: true
    });
    NodeBase.prototype.pathCore = function () {
        throw new Error("Not implemented");
    };
    Object.defineProperty(NodeBase.prototype, "delimiter", {
        get: function () {
            if (this._delimiterText)
                return this._delimiterText;
            return this._delimiterText = this.message.delimiters[this._delimiter];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "children", {
        get: function () {
            if (!this._children) {
                var parts = this._text.split(this.delimiter);
                var children = new Array(parts.length);
                for (var i = 0, l = parts.length; i < l; i++) {
                    children[i] = this.createChild(parts[i], i);
                }
                this._children = children;
            }
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    NodeBase.prototype.addChild = function (text) {
        this.setDirty();
        var child = this.createChild(text, this.children.length);
        this.children.push(child);
        return child;
    };
    NodeBase.prototype.createChild = function (text, index) {
        throw new Error("Not implemented");
    };
    NodeBase.prototype.setChild = function (child, index) {
        this.setDirty();
        var children = this.children;
        // if we already have a child at that index then replace it
        if (index < children.length) {
            children[index] = child;
            return child;
        }
        // otherwise, fill the @children array with empty children for any indexes between the end of the list
        // and the specified index.
        for (var i = children.length; i < index; i++) {
            children.push(this.createChild("", i));
        }
        children.push(child);
        return child;
    };
    NodeBase.prototype.setDirty = function () {
        if (!this._dirty) {
            this._dirty = true;
            if (this.parent) {
                this.parent.setDirty();
            }
        }
    };
    NodeBase.prototype._isSubPath = function (other) {
        if (this.path.length >= other.length)
            return false;
        var path = this.path;
        for (var i = 0, l = path.length; i < l; i++) {
            if (path[i] != other[i])
                return false;
        }
        return true;
    };
    NodeBase.prototype._remainderOf = function (other) {
        var path = this.path;
        return other.slice(path.length);
    };
    NodeBase.prototype._formatDateTime = function (date) {
        // check if there is a time component
        if (date.getHours() != 0 || date.getMinutes() != 0 || date.getSeconds() != 0 || date.getMilliseconds() != 0) {
            return this._formatDate(date) + Util.pad(date.getHours(), 2) + Util.pad(date.getMinutes(), 2) + Util.pad(date.getSeconds(), 2);
        }
        return this._formatDate(date);
    };
    NodeBase.prototype._formatDate = function (date) {
        return date.getFullYear().toString() + Util.pad(date.getMonth() + 1, 2) + Util.pad(date.getDate(), 2);
    };
    NodeBase.empty = new emptyNode_1.default();
    return NodeBase;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = NodeBase;
